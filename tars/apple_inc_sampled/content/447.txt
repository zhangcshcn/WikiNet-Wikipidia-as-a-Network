

  In
  
   computing
  
  ,
  
   preemption
  
  is the act of temporarily interrupting a
  
   task
  
  being carried out by a
  
   computer system
  
  , without requiring its cooperation, and with the intention of resuming the task at a later time. Such changes of the executed task are known as
  
   context switches
  
  . It is normally carried out by a
  
   privileged
  
  task or part of the system known as a preemptive
  
   scheduler
  
  , which has the power to
  
   preempt
  
  , or interrupt, and later resume, other tasks in the system.
 


  In any given system design, some operations performed by the system may not be preemptible. This usually applies to
  
   kernel
  
  functions and service
  
   interrupts
  
  which, if not permitted to
  
   run to completion
  
  , would tend to produce
  
   race conditions
  
  resulting in
  
   deadlock
  
  . Barring the scheduler from preempting tasks while they are processing kernel functions simplifies the kernel design at the expense of system responsiveness. The distinction between
  
   user mode
  
  and
  
   kernel mode
  
  , which determines privilege level within the system, may also be used to distinguish whether a task is currently preemptible.
 
  Most modern systems have
  
   preemptive kernels
  
  , designed to permit tasks to be preempted even when in kernel mode. Examples of such systems are
  
   Solaris
  
  2.0/SunOS 5.0,
  

    [1]
   


   Windows NT
  
  ,
  
   Linux kernel
  
  (2.6.x and newer),
  
   AIX
  
  and some
  
   BSD
  
  systems (
  
   NetBSD
  
  , since version 5).
 
  The term
  
   preemptive multitasking
  
  is used to distinguish a
  
   multitasking operating system
  
  , which permits preemption of tasks, from a
  
   cooperative multitasking
  
  system wherein processes or tasks must be explicitly programmed to
  
   yield
  
  when they do not need system resources.
 
  In simple terms: Preemptive multitasking involves the use of an
  
   interrupt mechanism
  
  which suspends the currently executing process and invokes a
  
   scheduler
  
  to determine which process should execute next. Therefore, all processes will get some amount of CPU time at any given time.
 
  In preemptive multitasking, the operating system
  
   kernel
  
  can also initiate a
  
   context switch
  
  to satisfy the
  
   scheduling policy
  
  's priority constraint, thus preempting the active task. In general, preemption means "prior seizure of". When the high priority task at that instance seizes the currently running task, it is known as preemptive scheduling.
 
  The term "preemptive multitasking" is sometimes mistakenly used when the intended meaning is more specific, referring instead to the class of scheduling policies known as
  
   time-shared scheduling
  
  , or
  

    time-sharing
   

  .
 
  Preemptive multitasking allows the computer system to more reliably guarantee each process a regular "slice" of operating time. It also allows the system to rapidly deal with important external events like incoming data, which might require the immediate attention of one or another process.
 
  At any specific time, processes can be grouped into two categories: those that are waiting for input or output (called "
  
   I/O bound
  
  "), and those that are fully utilizing the CPU ("
  
   CPU bound
  
  "). In early systems, processes would often "poll", or "
  
   busywait
  
  " while waiting for requested input (such as disk, keyboard or network input). During this time, the process was not performing useful work, but still maintained complete control of the CPU. With the advent of interrupts and preemptive multitasking, these I/O bound processes could be "blocked", or put on hold, pending the arrival of the necessary data, allowing other processes to utilize the CPU. As the arrival of the requested data would generate an interrupt, blocked processes could be guaranteed a timely return to execution.
 
  Although multitasking techniques were originally developed to allow multiple users to share a single machine, it soon became apparent that multitasking was useful regardless of the number of users. Many operating systems, from mainframes down to single-user personal computers and no-user
  
   control systems
  
  (like those in
  
   robotic spacecraft
  
  ), have recognized the usefulness of multitasking support for a variety of reasons. Multitasking makes it possible for a single user to run multiple applications at the same time, or to run "background" processes while retaining control of the computer.
 
  The period of time for which a process is allowed to run in a preemptive multitasking system is generally called the
  
   time slice
  
  or
  
   quantum
  
  . The scheduler is run once every time slice to choose the next process to run. The length of each time slice can be critical to balancing system performance vs process responsiveness - if the time slice is too short then the scheduler will consume too much processing time, but if the time slice is too long, processes will take longer to respond to input.
 
  An
  
   interrupt
  
  is scheduled to allow the
  
   operating system
  

   kernel
  
  to switch between processes when their time slices expire, effectively allowing the processorâ€™s time to be shared between a number of tasks, giving the illusion that it is dealing with these tasks simultaneously, or concurrently. The operating system which controls such a design is called a multi-tasking system.
 
  Today, nearly all operating systems support preemptive multitasking, including the current versions of
  
   Windows
  
  ,
  
   macOS
  
  ,
  
   Linux
  
  (including
  
   Android
  
  ) and
  
   iOS
  
  .
 
  Some of the earliest operating systems available to home users featuring preemptive multitasking were
  
   Sinclair QDOS
  
  (1984
  

    [2]
   

  ) and
  
   Amiga OS
  
  (1985). These both ran on
  
   Motorola 68000
  
  -family
  
   microprocessors
  
  without memory management. Amiga OS used
  
   dynamic loading
  
  of relocatable code blocks ("
  
   hunks
  
  " in Amiga jargon) to multitask preemptively all processes in the same flat address space.
 
  Early
  
   PC
  
  operating systems such as
  
   MS-DOS
  
  and
  
   PC DOS
  
  , did not support multitasking at all, however alternative operating systems such as
  
   MP/M-86
  
  (1981) and
  
   Concurrent CP/M-86
  
  did support preemptive multitasking. Other
  
   Unix-like
  
  systems including
  
   MINIX
  
  and
  
   Coherent
  
  provided preemptive multitasking on 1980s-era personal computers.
 
  Later DOS versions natively supporting preemptive multitasking/multithreading include
  
   Concurrent DOS
  
  ,
  
   Multiuser DOS
  
  ,
  
   Novell DOS
  
  (later called
  
   Caldera OpenDOS
  
  and
  
   DR-DOS
  
  7.02 and higher). Since
  
   Concurrent DOS 386
  
  , they could also run multiple DOS programs concurrently in virtual DOS machines.
 
  The earliest version of Windows to support a limited form of preemptive multitasking was
  
   Windows 2.1x
  
  , which used the
  
   Intel 80386
  
  's
  
   Virtual 8086 mode
  
  to run DOS applications in
  
   virtual 8086 machines
  
  , commonly known as "DOS boxes", which could be preempted. In
  
   Windows 95, 98 and Me
  
  , 32-bit applications were made preemptive by running each one in a separate address space, but 16-bit applications remained cooperative for backward compatibility.
  

    [3]
   

  In Windows 3.1x (protected mode), the kernel and virtual device drivers ran preemptively, but all 16-bit applications were non-preemptive and shared the same address space.
 
  Preemptive multitasking has always been supported by
  
   Windows NT
  
  (all versions),
  
   OS/2
  
  (native applications),
  
   Unix
  
  and
  
   Unix-like
  
  systems (such as
  
   Linux
  
  ,
  
   BSD
  
  and
  
   macOS
  
  ),
  
   VMS
  
  ,
  
   OS/360
  
  , and many other operating systems designed for use in the academic and medium-to-large business markets.
 
  Although there were plans to upgrade the cooperative multitasking found in the
  
   classic Mac OS
  
  to a preemptive model (and a preemptive API did exist in
  
   Mac OS 9
  
  , although in a limited sense
  

    [4]
   

  ), these were abandoned in favor of
  
   macOS
  
  that, as a hybrid of the old Mac System style and
  
   NeXTSTEP
  
  , is an operating system based on the
  
   Mach
  
  kernel and derived in part from
  
   BSD
  
  , which had always provided Unix-like preemptive multitasking.
 